#线程安全
多线程编码时出现的一个概念
线程安全的代码会通过同步机制确保各线程正常正确执行，不会出现数据污染。 
比如一个 ArrayList 类，在添加一个元素的时候，它可能会有两步来完成：
1. 在 Items[Size] 的位置存放此元素；
2. 增大 Size 的值。
在单线程运行的情况下，如果 Size = 0，添加一个元素后，此元素在位置 0，而且 Size=1；
而如果是在多线程情况下，比如有两个线程，线程 A 先将元素存放在位置 0。
但是此时 CPU 调度线程A暂停，线程 B 得到运行的机会。
线程B也向此 ArrayList 添加元素，因为此时 Size 仍然等于 0 （注意哦，我们假设的是添加一个元素是要两个步骤哦，
而线程A仅仅完成了步骤1），所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增加 Size 的值。
那好，我们来看看 ArrayList 的情况，元素实际上只有一个，存放在位置 0，而 Size 却等于 2。这就是“线程不安全”了。

#单例模式
系统中生成某种类型的对象有且只有一个，此时可以用单例模式
·构造方法私有
·用一个私有的静态变量引用实例
·提供一个共有的静态方法获取实例

 被声明为 private的变量 不能在类外看到，
 protected 同包他类，不同包子类、
 
 抽象方法不带大括号
 
 父类方法为抽象方法，必须重写。

父类方法为普通方法,可以重写也可以不重写。 

int i = 5;
int j = 10;
System.out.println(i + ~j);

-n=~n+1可推出~n=-n-1
故~j = -10-1 =-11 再+i = -6

#方法重载（overroad）
方法名相同，参数列表不同，返回值无关
#方法重写（覆盖） override
子类继承父类的方法，在子类中重写父类的方法，其中
方法名相同， 参数列表相同，返回值类型相同，方法体不同。